[{"title":"平面几何","url":"/2025/09/12/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/","content":"概念维度定义：一组相互独立的属性的数量。\n任意维度的取值与其他维度无关，比如二维空间里，$x$ 轴的取值与 $y$ 轴的取值无关，$y$ 轴的取值与 $x$ 轴的取值也无关。\n比如我们生活在三维空间里，而你正在看一篇在二维屏幕上显示的博客。\n点：可以看作零维；线：一维载体；面：二维载体；体：三维载体。\n坐标系坐标系是对点进行定位的规则，常见的有直角坐标系和极坐标系，一般&#x2F;默认是直角坐标系。\n直角坐标系\n\n将所有维度都为 $0$ 的点成为原点，用 $O$ 表示。\n\n将水平穿过原点的直线称为 $x$ 轴，左小右大；将竖直穿过原点的直线称为 $y$ 轴，下小上大。\n\n点的坐标 $(x, y)$ 就是这个点相对于原点在两轴上的偏移量。\n\n每一个维度的表示是等价的，置换维度不改变形状。\n\n\n极坐标系\n\n将所有维度都为 $0$ 的点成为极点，也用 $O$ 表示。\n\n将极点向右的水平射线称为极轴，作为旋转角的起点。\n\n点的坐标 $(r, \\theta)$ 由极径 $r$（该点到极点的距离）和极角 $\\theta$（由极轴逆时针转到极径的角度）表示。\n\n\n向量拥有大小和方向的量，也称矢量，是相对于标量而言的，标量是只有大小，没有方向的量，比如你的的体重就是标量 没有人的体重是向北的 60kg 吧，而物理中的力就用向量表示，因为力有方向，也有大小。\n向量可以用 $A$ 到 $B$ 的有向线段 $\\overrightarrow{AB}$ 表示，他的长度&#x2F;大小叫做向量的模，记作 $|AB|$。\n长度为零的向量被称为零向量，是唯一方向不确定的向量。长度为一的向量则被称为单位向量，与 $v$ 方向相同的单位向量称为 $v$ 的单位向量，记作 $v^0$。\n两个向量 $a$，$b$ 的夹角表示为 $\\lang a, b \\rang$（以 $a$ 为始边）。\n注意，向量没有位置属性，有向线段被平移后所表示的是同条向量。因此可以把有向线段的起点平移到原点，则终点就可以表示一个向量，此时终点的坐标就是原来有向线段两端的坐标差组成。比如下图，$\\overrightarrow{AB} \\longrightarrow \\overrightarrow{OC}$，则这两个向量都可以用 $(5,4)$ 表示。\n\n运算这里，向量都是用终点的坐标表示。\n加法\n把每一个维度的数值分别相加即可，若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OC} &#x3D; (x_1 + x_2, y_1 + y_2)$，。\n向量加法也满足交换律，即 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OB} + \\overrightarrow{OA} &#x3D; \\overrightarrow{OC}$。\n这里有衍生出一个概念，叫反向量，若 $\\overrightarrow{OP} &#x3D; (x, y)$，则其反向量 $\\overrightarrow{OQ} &#x3D; (-x, -y)$，满足 $\\overrightarrow{OP} + \\overrightarrow{OQ} &#x3D; (0, 0)$。\n减法加法的逆运算，两个维度分别相减即可。\n向量的加减运算称为平行四边形法则。\n点乘点乘符号为 $\\cdot$，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\cos \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 在 $\\overrightarrow{OA}$ 上投影的长度，是一个标量。比如在下图中，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; OA \\times OC$。\n\n计算方法 （当然，如果你想用定义去算的话也不是不可以）：若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; x_1 \\times x_2 + y_1 \\times y_2$。\n向量点乘满足交换律，可以用来判断向量的前后关系，如果对于两个向量 $a, b$，若 $a \\cdot b &#x3D; 0$，则 $\\lang a, b \\rang &#x3D; 90^\\circ$；若 $a \\cdot b &gt; 0$，则 $\\lang a, b \\rang &lt; 90^\\circ$；若 $a \\cdot b &lt; 0$，则 $\\lang a, b \\rang &gt; 90^\\circ$。\n叉乘叉乘符号为 $\\times$，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\sin \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 对于 $\\overrightarrow{OA}$ 上高的长度，也是一个标量。还是那上面那张图举例，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; OA \\times BC$，也就是以 $OA$ 和 $OB$ 为两边的平行四边形的面积（如果 $\\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang &lt; 0^\\circ$，则要取绝对值）。\n向量点乘不满足交换律（会变负），可以用来判断向量的左右关系，如果对于两个向量 $a, b$，若 $a \\times b &#x3D; 0$，则 $a$，$b$ 共线；若 $a \\times b &gt; 0$，则 $\\lang a, b \\rang &gt; 0^\\circ$；若 $a \\times b &lt; 0$，则 $\\lang a, b \\rang &lt; 0^\\circ$。\n例题&#x2F;应用洛谷 B2031 计算三角形面积可以发现是红题，也可以发现可以用海伦公式做\n直接对两边用叉乘取绝对值在除以二（$S_▱ \\div 2 &#x3D; S_\\triangle$）。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    double x, y;&#125;;constexpr int NR = 5;node p[NR];node mv(node x, node y) &#123; // make vector    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;double x_mul(node x, node y) &#123; // 叉乘    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    cin &gt;&gt; p[1].x &gt;&gt; p[1].y &gt;&gt; p[2].x &gt;&gt; p[2].y &gt;&gt; p[3].x &gt;&gt; p[3].y;    printf(&quot;%.2lf&quot;, abs(x_mul(mv(p[1], p[2]), mv(p[2], p[3]))) / (double)2.0);    return 0;&#125;\n\n洛谷 P1863 独眼兔每次选最右边的即可。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e3 + 5;int n, id = 1, vis[NR], nxt, tmp;node p[NR];node mv(node x, node y) &#123; // x --&gt; y    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int dis(node x, node y) &#123;    return (x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y);&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;        if (p[i].y &lt; p[id].y) id = i;    &#125;    vis[id] = 1;    cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    for (int T = n - 1; T --;) &#123;        nxt = -1;        for (int i = 1; i &lt;= n; ++ i) &#123;            if (vis[i]) continue;            if (nxt == -1) &#123;                nxt = i;                continue;            &#125;            tmp = x_mul(mv(p[id], p[nxt]), mv(p[nxt], p[i]));            if (tmp &lt; 0 || (tmp == 0 &amp;&amp; dis(p[id], p[nxt]) &gt; dis(p[id], p[i]))) nxt = i;        &#125;        id = nxt;        vis[id] = 1;        cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n洛谷 T269230 极角排序极角就是极坐标系里极径与极轴的夹角，分上下两部分，先按上下，同一边的用叉乘判断。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e5 + 5;int n, tmp;node p[NR];int find(node x) &#123;    if (x.y &gt;= 0) return 1;    return 2;&#125;int dis(node x) &#123;    return x.x * x.x + x.y * x.y;&#125;node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        if (find(x) != find(y)) return find(x) &lt; find(y);        tmp = x_mul(mv(&#123;0, 0&#125;, x), mv(&#123;0, 0&#125;, y));        if (tmp) return tmp &gt; 0;        return dis(x) &lt; dis(y);    &#125;);    for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n洛谷 P1142 轰炸我用的 DP，$dp_{i, j}$ 便是包含了第 $i$ 个和第 $j$ 个的线包含的点数。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 7e2 + 5;int n, dp[NR][NR], ans;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        return x.x &lt; y.x;    &#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) dp[i][j] = 2;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) &#123;            for (int k = 1; k &lt; i; ++ k) &#123;                if (x_mul(mv(p[k], p[i]), mv(p[i], p[j])) == 0) dp[i][j] = max(dp[i][j], dp[k][i] + 1);            &#125;            ans = max(ans, dp[i][j]);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\n洛谷 P1355 神秘大三角直接判断就好了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        char ch;        cin &gt;&gt; ch &gt;&gt; x &gt;&gt; ch &gt;&gt; y &gt;&gt; ch;        return;    &#125;&#125;;constexpr int NR = 5;int tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    for (int i = 1; i &lt;= 4; ++ i) p[i].read();    for (int i = 1; i &lt;= 3; ++ i) &#123;        int j = i + 1;        if (j == 4) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[4]));        if (tmp == 0) cnt0 ++;        else if (tmp &gt; 0) cnt1 ++;        else cnt_1 ++;    &#125;    if (cnt1 == 3 || cnt_1 == 3) cout &lt;&lt; 1;    else if (cnt0 == 1 &amp;&amp; (cnt1 == 2 || cnt_1 == 2)) cout &lt;&lt; 3;    else if (cnt0 == 2) cout &lt;&lt; 4;    else cout &lt;&lt; 2;    return 0;&#125;\n\n洛谷 P1183 多边形的面积\n把每个加起来就可以了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        cin &gt;&gt; x &gt;&gt; y;        return;    &#125;&#125;;constexpr int NR = 1e2 + 5;int n, tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;long long ans;int main() &#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) p[i].read();    for (int i = 1; i &lt;= n; ++ i) &#123;        int j = i + 1;        if (j == n + 1) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[0]));        ans += tmp;    &#125;    cout &lt;&lt; ans / 2;    return 0;&#125;","categories":["总结"],"tags":["YL总结","概念"]},{"title":"20250903第一次拔高训练","url":"/2025/09/09/20250903%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%94%E9%AB%98%E8%AE%AD%E7%BB%83/","content":"A\n如果 Alice 在两个奖品之间（包含两端），则不管 Bob 站在哪里都不可能离两个奖品都更近，输出 NO。\n\n否则 Alice 站在两个奖品的左边或右边，Bob 就可以站在比 Alice 更近的位置从而取胜，输出 YES。\n\n\nB交易次数最小的情况只有一种（$3$ 进制），直接算就好了。\n从左到右遍历，对与奇数位置，优先减右边的，如果减\nC直接模拟贪心，只需要保证对于每个偶数位，它两边的两个位置的和不大于它即可。\n从左到右遍历，对于每个位置，优先减右边，右边到零再减左边。\nD对于每个深度大于一的叶节点都要进行一次操作，找到答案最小的即可。\nE为什么会用记忆化搜索啊？\n直接模拟，如果碰到了和之前时间（$\\bmod ; k$）、位置、方向都一样的就进入循环了，不可能走出来，如果到了 $0$ 或 $n + 1$ 就走出来了。\nF前缀和 $+$ 指针，记录上次 $&gt;x$ 的位置。\n用 map 维护和区间。\n\n如果这个点比 $x$ 大，清空 map，指针指到现在的位置。\n如果这个点是 $x$，把 $(\\footnotesize \\texttt{指针位置} \\normalsize, \\footnotesize \\texttt{现在位置} \\normalsize]$ 的前缀和加到 map 里面，再给答案加上 $\\text{sum}_i - s$ 的个数。\n\n最后输出 $x$ 即可。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"区间DP","url":"/2025/09/16/%E5%8C%BA%E9%97%B4DP/","content":"区间 $\\texttt{DP}$很明显，区间 $\\texttt{DP}$ 是一种 DP。 是一种以区间为状态的 $\\texttt{DP}$，$dp_{l, r}$ 表示区间 $[l, r]$ 的答案（$\\min$，$\\max$，个数 $\\dots$）。\n一般来说，$dp_{i, j}$ 可以从 $[i, j]$ 的子区间转移而来，所以一般先枚举长度，再枚举左端点，再算出右端点，进行 $\\texttt{DP}$。\n有些环形的问题也可以考虑区间 $\\texttt{DP}$，将环断成链，再复制一遍，进行 $\\texttt{DP}$。\n例题洛谷 P1775 石子合并（弱化版）设 $dp_{i, j}$ 表示合并区间 $[i, j]$ 的最小代价，则 $dp_{i, j}$ 可以从所有的 $dp_{i, k} + dp_{k + 1, j} + \\sum_{p&#x3D;1}^{n} a_p$ 转移过来（$i \\leq k &lt; j$），而 $\\sum_{p&#x3D;1}^{n} a_p$ 又可以用前缀和维护，所以就可以 $\\mathcal{O(n^3)}$ 求出答案了。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e2 + 5;int n, a[NR], dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp); // 初始化为无穷大    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        a[i] += a[i - 1]; // 前缀和        dp[i][i] = 0; // 区间长度为 1 时，代价为 0    &#125;    for (int len = 2; len &lt;= n; ++ len) &#123; // 枚举区间长度        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123; // 枚举左端点            int j = i + len - 1; // 计算右端点            for (int k = i; k &lt; j; ++ k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1]; // 加上区间和        &#125;    &#125;    cout &lt;&lt; dp[1][n];    return 0;&#125;\n\n洛谷 P1880 [NOI1995] 石子合并真正的石子合并，和上题类似，只不过要维护两个 $\\texttt{DP}$，一个是最小代价，一个是最大代价，还要拆环，再复制一遍。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e2 + 5;int n, a[NR], dp[NR][NR], ans = INT_MAX;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp);    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        a[i + n] = a[i]; // 复制一遍    &#125;    n *= 2; // n 变成 2n    for (int i = 1; i &lt;= n; ++ i) &#123;        a[i] += a[i - 1]; // 前缀和        dp[i][i] = 0;    &#125;    for (int len = 2; len &lt;= n / 2; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1;            for (int k = i; k &lt; j; ++ k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1];            if (len == n / 2) ans = min(ans, dp[i][j]);            // 要的答案长度是 n/2        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    // 同理，求最大代价    // ans 不需要初始化，因为最大值一定大于等于最小值    memset(dp, -0x3f, sizeof dp);    for (int i = 1; i &lt;= n; ++ i) dp[i][i] = 0;    for (int len = 2; len &lt;= n / 2; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1;            for (int k = i; k &lt; j; ++ k) dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1];            if (len == n / 2) ans = max(ans, dp[i][j]);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\n\n洛谷 P2858 [USACO06FEB] Treats for the Cows G&#x2F;S也是一道很经典的区间 $\\texttt{DP}$，他每天只卖两端的，为了符合习惯， ，可以把操作反过来，设 $dp_{i, j}$ 是卖了 $i \\sim j$ 的糖的最大收益。$dp_{i, j}$ 可以从 $dp_{i + 1, j} + \\footnotesize \\texttt{陈年时间} \\normalsize \\times a_i$ 和 $dp_{i, j - 1} + \\footnotesize \\texttt{陈年时间} \\normalsize \\times a_j$ 转移过来，陈年时间是 $n - \\text{len} - 1$（其中 $\\text{len}$ 是区间长度），因为每次卖糖都会减少陈年时间。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int NR = 2e3 + 5;int n, a[NR];ll dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        dp[i][i] = (ll)a[i] * n; // 区间长度为 1 时，卖掉唯一的糖果，陈年时间为 n    &#125;    for (int len = 2; len &lt;= n; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1, now = n - len + 1; // 计算右端点和陈年时间            dp[i][j] = max(dp[i + 1][j] + (ll)a[i] * now, dp[i][j - 1] + (ll)a[j] * now);            // 转移        &#125;    &#125;    cout &lt;&lt; dp[1][n];    return 0;&#125;\n","categories":["总结"],"tags":["YL总结","算法"]},{"title":"20250909第二次拔高训练","url":"/2025/09/16/20250909%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8B%94%E9%AB%98%E8%AE%AD%E7%BB%83/","content":"A直接算就好了。\nB原题，答案就是 $\\lfloor \\dfrac{ \\footnotesize \\texttt{树的直径}}{2} \\rfloor \\times 2$。\nC\n此外，汽车还装备了一次性加速装置，可以在某次行驶时将最远距离提升至 $2L$。\n\n可以转换为多设一个加油站，二分答案即可（我把左端点设成了 0，喜提 RE $\\times 1$）。\nD他要求路径上的最大边权在 $[L, R]$ 之间，所以最重要的就是最大边权。\n把所有边从小到大排序，依次加边，所以每次加的边都是当前的最大边权，然后用并查集维护连通性连通块，统计答案即可。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int NR = 1e5 + 5, MR = 2e5 + 5;int n, m, l, r, fa[NR], cnt[NR];ll ans;int find(int x) &#123;    if (fa[x] == x) return x;    return fa[x] = find(fa[x]);&#125;struct node&#123;    int u, v, w;&#125;e[MR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r;    for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;    sort(e + 1, e + m + 1, [](node x, node y) &#123;        return x.w &lt; y.w; // 按边权从小到大排序    &#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        fa[i] = i; // 并查集初始化        cnt[i] = 1; // 每个连通块的大小初始化为 1    &#125;    for (int i = 1; i &lt;= m; ++ i) &#123;        if (e[i].w &gt; r) break; // 边权超过 r 就不考虑了        int u = find(e[i].u), v = find(e[i].v), w = e[i].w;        if (u == v) continue;        if (w &gt;= l) ans += cnt[u] * 1ll * cnt[v]; // 只有边权在 [L, R] 之间的边才贡献答案，当前连起来了 u, v 两个连通块，统计答案。        fa[u] = v;        cnt[v] += cnt[u]; // 合并连通块    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nE区间 $\\texttt{DP}$，设 $dp_{k, i, j}$ 表示第 $k$ 行搭了 $i \\sim j$ 列的方案数，转移见代码。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int mod = 1e9 + 7, NR = 1e2 + 5;ll n, m, dp[NR][NR][NR], s[NR][NR], sum[NR][NR], ans = 1/*不放也可以*/;char a[NR][NR];signed main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= m; ++ j) &#123;            cin &gt;&gt; a[i][j];            s[i][j] += s[i][j - 1] + (a[i][j] == &#x27;X&#x27;);        &#125;    &#125;    for (int i = 1; i &lt;= m; ++ i) &#123;        for (int j = i; j &lt;= m; ++ j) &#123;            if (s[n][j] - s[n][i - 1] != 0) continue;            dp[n][i][j] = 1;            ans ++;        &#125;    &#125;    for (int k = n - 1; k &gt;= 1; -- k) &#123;        for (int i = 1; i &lt;= m; ++ i) &#123;            for (int j = m; j &gt;= i; -- j) &#123;                sum[i][j] = dp[k + 1][i][j]; // 从下一行直接过来                sum[i][j] += sum[i - 1][j] + sum[i][j + 1] - sum[i - 1][j + 1];                // 因为这一行的下面不一定是 (i, j)，要考虑所有的 (i&#x27;, j&#x27;)，其中 i&#x27; &lt;= i, j&#x27; &gt;= j                // 这正好又是 sum[i - 1][j] + sum[i][j + 1] - sum[i - 1][j + 1] （容斥）                sum[i][j] %= mod;            &#125;        &#125;        for (int len = m; len &gt;= 1; -- len) &#123;            for (int i = 1; i + len - 1 &lt;= m; ++ i) &#123;                int j = i + len - 1;                if (s[k][j] - s[k][i - 1] != 0) continue; // 该区间有障碍物                dp[k][i][j] = sum[i][j]; // dp 就是 sum                dp[k][i][j] %= mod;                ans += dp[k][i][j]; // 累加答案                ans %= mod;            &#125;        &#125;    &#125;    cout &lt;&lt; ans;        return 0;&#125;\n\nF还没完全搞懂，容我再想想。为什么输出 -1 有 60 pts\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"搜索","url":"/2025/09/01/%E6%90%9C%E7%B4%A2/","content":"$\\texttt{1.}$DFS\n不撞南墙不回头\n\nDFS 的特点就是“一条路走到黑，撞南墙了再回头”，每次递归调用都尝试向一个方向前进，如果遇到障碍，则回溯到上一个节点，尝试其他方向。所以 DFS 一般使用递归实现。\n模板（一维）：\nvoid dfs(int x) &#123;    if (/*x 超出范围*/) &#123;        // 统计/输出结果        return;    &#125;    for (/*所有可能的后继状态*/) &#123;        if (/*x 和 i 不符合条件*/) &#123;            continue;        &#125;        // 标记 x 和 i 的关系        dfs(i);        // 撤销标记    &#125;    return;&#125;\n\n$\\texttt{2.}$BFSBFS 的特点就是“先搜最近的，再搜远的”，每次选出离起点最近的状态，遍历所有可能的后继状态，再把后继状态加进待选的集合中。所以 BFS 一般使用队列实现。在等&#x2F;无权图中，第一次找到的路径长度就是最短路。\n模板（一维）：\nvoid bfs(int s) &#123;    queue&lt;int&gt; q;    q.push(s);    // 清空标记、最短路数组    while (!q.empty()) &#123;        int x = q.front();        q.pop();        for (/*所有可能的后继状态*/) &#123;            if (/*不符合条件*/) continue;            // 标记            q.push(/*后继状态*/);        &#125;    &#125;    return;&#125;\n\n01BFS边权只有 0 或 1（0 或一个固定值）的图中的最短路，可以用双端队列实现，每次把 0 的边权节点放到队头，把 1 的边权节点放到队尾，这样每次取到的都是当前最短路节点，其实本质上是 Dijkstra。\n$\\texttt{3.}$例题A$\\texttt.$ 洛谷 P1706 全排列问题DFS，每次只可以选之前没有选过的数字，所以用数组标记一下即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e1;int n, p[NR], f[NR];// p 数组存储排列，f 数组标记数字是否被选过void dfs(int x) &#123;    if (x &gt; n) &#123;        for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; &quot;    &quot; &lt;&lt; p[i];        cout &lt;&lt; &#x27;\\n&#x27;;        // 输出排列        return;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        if (f[i]) continue;        f[i] = 1;        p[x] = i;        // 标记        dfs(x + 1);        f[i] = 0;        // 撤销标记    &#125;    return;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    dfs(1);    return 0;&#125;\n\nD$\\texttt.$ 洛谷 P1746 离开中山路BFS，每次向上下左右四个方向扩展，不能到店铺里，直到找到终点。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e3 + 5;int n, dis[NR][NR], vis[NR][NR], ans;bool a[NR][NR];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;// 方向数组int sx, sy, ex, ey;int bfs() &#123;    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(&#123;sx, sy&#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            dis[i][j] = INT_MAX;            vis[i][j] = 0;        &#125;    &#125;    dis[sx][sy] = 0;    vis[sx][sy] = 1;    while (!q.empty()) &#123;        int tx = q.front().first, ty = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; ++ i) &#123;            int nx = tx + dx[i], ny = ty + dy[i];            if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; n) continue;            // 超出范围            if (vis[nx][ny] || a[nx][ny]) continue;            // 已经访问过或者到店铺里            dis[nx][ny] = dis[tx][ty] + 1;            vis[nx][ny] = 1;            if (nx == ex &amp;&amp; ny == ey) return dis[nx][ny];            // 到达终点，返回答案            q.push(&#123;nx, ny&#125;);        &#125;    &#125;    return -1;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            char ch;            cin &gt;&gt; ch;            a[i][j] = ch - &#x27;0&#x27;;        &#125;    &#125;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;    cout &lt;&lt; bfs();    return 0;&#125;\n\n","categories":["总结"],"tags":["YL总结","算法"]},{"title":"线性DP","url":"/2025/09/13/%E7%BA%BF%E6%80%A7DP/","content":"线性 $\\texttt{DP}$所有 $\\texttt{DP}$ 都要满足的条件：\n\n最优子结构：即动规中的 状态，可以同归一些状态推出它的后继状态，最终求出答案。\n重叠子问题：即子问题之间有重复计算的部分，可以用一个数组记录下来，避免重复计算。\n无后效性：已经确定的状态，不会因为后续状态的变化而变化。\n\n线性 $\\texttt{DP}$ 是一类状态定义与题目条件线性相关的 $\\texttt{DP}$：如果题目给定一个一味的序列，要你求最大&#x2F;最小&#x2F;个数&#x2F;概率等，那么 $\\texttt{dp}$ 状态就是一维的，如果是二维棋盘上的问题，那么 $\\texttt{dp}$ 状态就是二维的。\n例题洛谷 P5146 最大差值好吧，也不知道为什么这题会要 $\\texttt{dp}$，一个变量就好了，题目要求：$$\\max_{1 \\leq i &lt; j \\leq n} {a_j - a_i}$$\n用一个变量存到当前位置的最小值，然后每次更新答案即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;long long n, a, minn = LONG_LONG_MAX, ans = LONG_LONG_MIN;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    while (n --) &#123;        cin &gt;&gt; a;        if (minn &gt;= 1e17) minn = a;        else &#123;            ans = max(ans, a - minn);            minn = min(minn, a);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nAtcoder Tessoku Book DP a - Frog 1真正的线性 $\\texttt{dp}$，设 $dp_i$ 为到达第 $i$ 个石头所需要的最小花费，则对于 $i \\geq 3$，$dp_i &#x3D; \\min(dp_{i - 1} + |a_i - a_{i - 1}|, dp_{i - 2} + |a_i - a_{i - 2}|)$，$dp_1 &#x3D; 0$，$dp_2 &#x3D; |a_2 - a_1|$，最后答案就是 $dp_n$。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e5 + 5;int n, a[NR], dp[NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp);    dp[1] = 0;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        if (i == 2) &#123;            dp[i] = abs(a[2] - a[1]);        &#125;        else if (i &gt; 2) dp[i] = min(dp[i - 1] + abs(a[i] - a[i - 1]), dp[i - 2] + abs(a[i] - a[i - 2]));    &#125;    cout &lt;&lt; dp[n];    return 0;&#125;\n\nAtcoder DP F - LCS最长公共子序列，设 $dp_{i, j}$ 表示 $s_{1 \\sim i}$ 和 $t_{1 \\sim j}$ 的 $\\texttt{LCS}$ 的长度，则对于 $i, j \\geq 1$，$dp_{i, j} &#x3D; \\max(dp_{i - 1, j}, dp_{i, j - 1}, dp_{i - 1, j - 1} + [s_i &#x3D; t_j])$，$\\texttt{LCS}$ 长度就是 $dp_{n, m}$，再从 $(n, m)$ 往回反推所有状态。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e3 + 5;string s, t;int n, m, dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; s &gt;&gt; t;    n = s.size(); // 记录长度    m = t.size();    s = &#x27;\\0&#x27; + s; // 为了方便，从 1 开始编号    t = &#x27;\\0&#x27; + t;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= m; ++ j) &#123;            if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1;            dp[i][j] = max(&#123;dp[i][j], dp[i - 1][j], dp[i][j - 1]&#125;);        &#125;    &#125;    string ans = &quot;&quot;;    int x = n, y = m; // 当前在 dp[i][j]，从 (n, m) 开始反推    while (ans.size() &lt; dp[n][m]) &#123;        if (s[x] == t[y] &amp;&amp; dp[x][y] == dp[x - 1][y - 1] + 1) &#123;            // 如果当前字符相等，并且 dp[x][y] = dp[x - 1][y - 1] + 1，说明这个字符是公共的            ans = s[x] + ans; // 将这个字符加到答案的开头            x --;            y --;        &#125;        else if (x &gt; 0 &amp;&amp; dp[x][y] == dp[x - 1][y]) x --; // 其他情况        else y --;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nAtcoder ABC410 E - Battles in a Row设 $dp_{i, j}$ 表示魔法值用了 $i$，生命值用了 $j$ 时打败的最多的怪物的数量，答案就是$$\\max_{1 \\leq i \\leq h, 1 \\leq j \\leq m} {dp_{i, j}}$$，转移详见代码。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e3 + 5;int n, h, m, a[NR], b[NR], dp[NR][NR], ans;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; h &gt;&gt; m;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i] &gt;&gt; b[i];    memset(dp, -1, sizeof dp);    dp[0][0] = 0;    for (int i = 0; i &lt;= h; ++ i) &#123;        for (int j = 0; j &lt;= m; ++ j) &#123;            if (dp[i][j] == -1) continue;            int pos = dp[i][j] + 1; // 现在要打的怪物            ans = max(ans, dp[i][j]); //顺便统计答案            if (a[pos] + i &lt;= h) dp[i + a[pos]][j] = max(dp[i + a[pos]][j], pos); // 用魔法值            if (b[pos] + j &lt;= m) dp[i][j + b[pos]] = max(dp[i][j + b[pos]], pos); // 用生命值        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;","categories":["总结"],"tags":["YL总结","算法"]}]