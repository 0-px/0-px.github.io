[{"title":"搜索","url":"/2025/09/01/%E6%90%9C%E7%B4%A2/","content":"$\\texttt{1.}$DFS\n不撞南墙不回头\n\nDFS 的特点就是“一条路走到黑，撞南墙了再回头”，每次递归调用都尝试向一个方向前进，如果遇到障碍，则回溯到上一个节点，尝试其他方向。所以 DFS 一般使用递归实现。\n模板（一维）：\nvoid dfs(int x) &#123;    if (/*x 超出范围*/) &#123;        // 统计/输出结果        return;    &#125;    for (/*所有可能的后继状态*/) &#123;        if (/*x 和 i 不符合条件*/) &#123;            continue;        &#125;        // 标记 x 和 i 的关系        dfs(i);        // 撤销标记    &#125;    return;&#125;\n\n$\\texttt{2.}$BFSBFS 的特点就是“先搜最近的，再搜远的”，每次选出离起点最近的状态，遍历所有可能的后继状态，再把后继状态加进待选的集合中。所以 BFS 一般使用队列实现。在等&#x2F;无权图中，第一次找到的路径长度就是最短路。\n模板（一维）：\nvoid bfs(int s) &#123;    queue&lt;int&gt; q;    q.push(s);    // 清空标记、最短路数组    while (!q.empty()) &#123;        int x = q.front();        q.pop();        for (/*所有可能的后继状态*/) &#123;            if (/*不符合条件*/) continue;            // 标记            q.push(/*后继状态*/);        &#125;    &#125;    return;&#125;\n\n01BFS边权只有 0 或 1（0 或一个固定值）的图中的最短路，可以用双端队列实现，每次把 0 的边权节点放到队头，把 1 的边权节点放到队尾，这样每次取到的都是当前最短路节点，其实本质上是 Dijkstra。\n$\\texttt{3.}$例题A$\\texttt.$ 洛谷 P1706 全排列问题DFS，每次只可以选之前没有选过的数字，所以用数组标记一下即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e1;int n, p[NR], f[NR];// p 数组存储排列，f 数组标记数字是否被选过void dfs(int x) &#123;    if (x &gt; n) &#123;        for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; &quot;    &quot; &lt;&lt; p[i];        cout &lt;&lt; &#x27;\\n&#x27;;        // 输出排列        return;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        if (f[i]) continue;        f[i] = 1;        p[x] = i;        // 标记        dfs(x + 1);        f[i] = 0;        // 撤销标记    &#125;    return;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    dfs(1);    return 0;&#125;\n\nD$\\texttt.$ 洛谷 P1746 离开中山路BFS，每次向上下左右四个方向扩展，不能到店铺里，直到找到终点。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e3 + 5;int n, dis[NR][NR], vis[NR][NR], ans;bool a[NR][NR];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;// 方向数组int sx, sy, ex, ey;int bfs() &#123;    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(&#123;sx, sy&#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            dis[i][j] = INT_MAX;            vis[i][j] = 0;        &#125;    &#125;    dis[sx][sy] = 0;    vis[sx][sy] = 1;    while (!q.empty()) &#123;        int tx = q.front().first, ty = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; ++ i) &#123;            int nx = tx + dx[i], ny = ty + dy[i];            if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; n) continue;            // 超出范围            if (vis[nx][ny] || a[nx][ny]) continue;            // 已经访问过或者到店铺里            dis[nx][ny] = dis[tx][ty] + 1;            vis[nx][ny] = 1;            if (nx == ex &amp;&amp; ny == ey) return dis[nx][ny];            // 到达终点，返回答案            q.push(&#123;nx, ny&#125;);        &#125;    &#125;    return -1;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            char ch;            cin &gt;&gt; ch;            a[i][j] = ch - &#x27;0&#x27;;        &#125;    &#125;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;    cout &lt;&lt; bfs();    return 0;&#125;\n\n","categories":["总结"],"tags":["YL总结","算法"]}]