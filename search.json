[{"title":"20250909第二次拔高训练","url":"/blog/20250909%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8B%94%E9%AB%98%E8%AE%AD%E7%BB%83/","content":"A直接算就好了。\nB原题，答案就是 $\\lfloor \\dfrac{ \\footnotesize \\texttt{树的直径}}{2} \\rfloor \\times 2$。\nC\n此外，汽车还装备了一次性加速装置，可以在某次行驶时将最远距离提升至 $2L$。\n\n可以转换为多设一个加油站，二分答案即可（我把左端点设成了 0，喜提 RE $\\times 1$）。\nD他要求路径上的最大边权在 $[L, R]$ 之间，所以最重要的就是最大边权。\n把所有边从小到大排序，依次加边，所以每次加的边都是当前的最大边权，然后用并查集维护连通性连通块，统计答案即可。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int NR = 1e5 + 5, MR = 2e5 + 5;int n, m, l, r, fa[NR], cnt[NR];ll ans;int find(int x) &#123;    if (fa[x] == x) return x;    return fa[x] = find(fa[x]);&#125;struct node&#123;    int u, v, w;&#125;e[MR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r;    for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;    sort(e + 1, e + m + 1, [](node x, node y) &#123;        return x.w &lt; y.w; // 按边权从小到大排序    &#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        fa[i] = i; // 并查集初始化        cnt[i] = 1; // 每个连通块的大小初始化为 1    &#125;    for (int i = 1; i &lt;= m; ++ i) &#123;        if (e[i].w &gt; r) break; // 边权超过 r 就不考虑了        int u = find(e[i].u), v = find(e[i].v), w = e[i].w;        if (u == v) continue;        if (w &gt;= l) ans += cnt[u] * 1ll * cnt[v]; // 只有边权在 [L, R] 之间的边才贡献答案，当前连起来了 u, v 两个连通块，统计答案。        fa[u] = v;        cnt[v] += cnt[u]; // 合并连通块    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nE区间 $\\texttt{DP}$，设 $dp_{k, i, j}$ 表示第 $k$ 行搭了 $i \\sim j$ 列的方案数，转移见代码。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int mod = 1e9 + 7, NR = 1e2 + 5;ll n, m, dp[NR][NR][NR], s[NR][NR], sum[NR][NR], ans = 1/*不放也可以*/;char a[NR][NR];signed main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= m; ++ j) &#123;            cin &gt;&gt; a[i][j];            s[i][j] += s[i][j - 1] + (a[i][j] == &#x27;X&#x27;);        &#125;    &#125;    for (int i = 1; i &lt;= m; ++ i) &#123;        for (int j = i; j &lt;= m; ++ j) &#123;            if (s[n][j] - s[n][i - 1] != 0) continue;            dp[n][i][j] = 1;            ans ++;        &#125;    &#125;    for (int k = n - 1; k &gt;= 1; -- k) &#123;        for (int i = 1; i &lt;= m; ++ i) &#123;            for (int j = m; j &gt;= i; -- j) &#123;                sum[i][j] = dp[k + 1][i][j]; // 从下一行直接过来                sum[i][j] += sum[i - 1][j] + sum[i][j + 1] - sum[i - 1][j + 1];                // 因为这一行的下面不一定是 (i, j)，要考虑所有的 (i&#x27;, j&#x27;)，其中 i&#x27; &lt;= i, j&#x27; &gt;= j                // 这正好又是 sum[i - 1][j] + sum[i][j + 1] - sum[i - 1][j + 1] （容斥）                sum[i][j] %= mod;            &#125;        &#125;        for (int len = m; len &gt;= 1; -- len) &#123;            for (int i = 1; i + len - 1 &lt;= m; ++ i) &#123;                int j = i + len - 1;                if (s[k][j] - s[k][i - 1] != 0) continue; // 该区间有障碍物                dp[k][i][j] = sum[i][j]; // dp 就是 sum                dp[k][i][j] %= mod;                ans += dp[k][i][j]; // 累加答案                ans %= mod;            &#125;        &#125;    &#125;    cout &lt;&lt; ans;        return 0;&#125;\n\nF还没完全搞懂，容我再想想。为什么输出 -1 有 60 pts\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"20251007国庆联考day3","url":"/blog/20251007%E5%9B%BD%E5%BA%86%E8%81%94%E8%80%83day3/","content":"\n\n\n\nT1\nT2\nT3\nT4\n总分\n\n\n\n预估\n100\n100\n100\n25\n325\n\n\n实际\n100\n100\n100\n30\n330\n\n\n最后一题经过不懈打表（打到了 460），25pts $\\rightarrow$ 30pts\nT1 - remainder暴力枚举 $l \\sim r$ 求答案。\nT2 - multiply把 $a$ 中的 2 和 5 拆出来，因为最后要有 $k$ 个零，所以 2 和 5 都要有 $k$ 个，把不够的用 $b$ 补上即可。\nT3 - tree改变一个节点只会改变他自己以及他的搜友直接和间接的父亲节点，而这又是一棵完全二叉树，所以神的是 $\\log n$ 级别的，枚举每个被改变的节点即可。\nT4 - structure正解：\n一共有 $\\dfrac{n \\times (n - 1)}{2}$ 个正&#x2F;逆序对，则正、逆序对各要 $\\dfrac{n \\times (n - 1)}{4}$ 个。\n要字典序最小，所以第一位肯定要放 1，会带来 $n - 1$ 个正序对，第二位肯定要放 2，会带来 $n - 2$ 个正序对…… 直到正序对个数超标了，剩下的反过来放就构造出来了。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"20251006国庆联考day2","url":"/blog/20251006%E5%9B%BD%E5%BA%86%E8%81%94%E8%80%83day2/","content":"\n\n\n\nT1\nT2\nT3\nT4\n总分\n\n\n\n预估\n100\n100\n100\n100\n400\n\n\n实际\n100\n80\n70\n90\n340\n\n\n怎么还预估 AK 了\nT1 - sum\n减法：$\\footnotesize\\texttt{总和} \\normalsize - 2 \\times \\footnotesize\\texttt{最小值}$；\n求余：最小值。\n\nT2 - palindrome先把它变成回文串，再把字典序变成最小。\nT3 - color又是诈骗，和树没有一点关系（可以直接从叶节点往根节点染），答案就是所有边中两节点权值之和为质数的边数。\nT4 - divide充分发扬人类智慧，满足条件的 $c_i$ 一定不会很大，枚举商为 $1 \\sim 10$，对每个统计答案再求最大值即可。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"20250903第一次拔高训练","url":"/blog/20250903%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%94%E9%AB%98%E8%AE%AD%E7%BB%83/","content":"A\n如果 Alice 在两个奖品之间（包含两端），则不管 Bob 站在哪里都不可能离两个奖品都更近，输出 NO。\n\n否则 Alice 站在两个奖品的左边或右边，Bob 就可以站在比 Alice 更近的位置从而取胜，输出 YES。\n\n\nB交易次数最小的情况只有一种（$3$ 进制），直接算就好了。\n从左到右遍历，对与奇数位置，优先减右边的，如果减\nC直接模拟贪心，只需要保证对于每个偶数位，它两边的两个位置的和不大于它即可。\n从左到右遍历，对于每个位置，优先减右边，右边到零再减左边。\nD对于每个深度大于一的叶节点都要进行一次操作，找到答案最小的即可。\nE为什么会用记忆化搜索啊？\n直接模拟，如果碰到了和之前时间（$\\bmod ; k$）、位置、方向都一样的就进入循环了，不可能走出来，如果到了 $0$ 或 $n + 1$ 就走出来了。\nF前缀和 $+$ 指针，记录上次 $&gt;x$ 的位置。\n用 map 维护和区间。\n\n如果这个点比 $x$ 大，清空 map，指针指到现在的位置。\n如果这个点是 $x$，把 $(\\footnotesize \\texttt{指针位置} \\normalsize, \\footnotesize \\texttt{现在位置} \\normalsize]$ 的前缀和加到 map 里面，再给答案加上 $\\text{sum}_i - s$ 的个数。\n\n最后输出 $x$ 即可。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"区间DP","url":"/blog/%E5%8C%BA%E9%97%B4DP/","content":"区间 $\\texttt{DP}$很明显，区间 $\\texttt{DP}$ 是一种 DP。 是一种以区间为状态的 $\\texttt{DP}$，$dp_{l, r}$ 表示区间 $[l, r]$ 的答案（$\\min$，$\\max$，个数 $\\dots$）。\n一般来说，$dp_{i, j}$ 可以从 $[i, j]$ 的子区间转移而来，所以一般先枚举长度，再枚举左端点，再算出右端点，进行 $\\texttt{DP}$。\n有些环形的问题也可以考虑区间 $\\texttt{DP}$，将环断成链，再复制一遍，进行 $\\texttt{DP}$。\n例题洛谷 P1775 石子合并（弱化版）设 $dp_{i, j}$ 表示合并区间 $[i, j]$ 的最小代价，则 $dp_{i, j}$ 可以从所有的 $dp_{i, k} + dp_{k + 1, j} + \\sum_{p&#x3D;1}^{n} a_p$ 转移过来（$i \\leq k &lt; j$），而 $\\sum_{p&#x3D;1}^{n} a_p$ 又可以用前缀和维护，所以就可以 $\\mathcal{O(n^3)}$ 求出答案了。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e2 + 5;int n, a[NR], dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp); // 初始化为无穷大    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        a[i] += a[i - 1]; // 前缀和        dp[i][i] = 0; // 区间长度为 1 时，代价为 0    &#125;    for (int len = 2; len &lt;= n; ++ len) &#123; // 枚举区间长度        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123; // 枚举左端点            int j = i + len - 1; // 计算右端点            for (int k = i; k &lt; j; ++ k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1]; // 加上区间和        &#125;    &#125;    cout &lt;&lt; dp[1][n];    return 0;&#125;\n\n洛谷 P1880 [NOI1995] 石子合并真正的石子合并，和上题类似，只不过要维护两个 $\\texttt{DP}$，一个是最小代价，一个是最大代价，还要拆环，再复制一遍。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e2 + 5;int n, a[NR], dp[NR][NR], ans = INT_MAX;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp);    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        a[i + n] = a[i]; // 复制一遍    &#125;    n *= 2; // n 变成 2n    for (int i = 1; i &lt;= n; ++ i) &#123;        a[i] += a[i - 1]; // 前缀和        dp[i][i] = 0;    &#125;    for (int len = 2; len &lt;= n / 2; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1;            for (int k = i; k &lt; j; ++ k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1];            if (len == n / 2) ans = min(ans, dp[i][j]);            // 要的答案长度是 n/2        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    // 同理，求最大代价    // ans 不需要初始化，因为最大值一定大于等于最小值    memset(dp, -0x3f, sizeof dp);    for (int i = 1; i &lt;= n; ++ i) dp[i][i] = 0;    for (int len = 2; len &lt;= n / 2; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1;            for (int k = i; k &lt; j; ++ k) dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);            dp[i][j] += a[j] - a[i - 1];            if (len == n / 2) ans = max(ans, dp[i][j]);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\n\n洛谷 P2858 [USACO06FEB] Treats for the Cows G&#x2F;S也是一道很经典的区间 $\\texttt{DP}$，他每天只卖两端的，为了符合习惯， ，可以把操作反过来，设 $dp_{i, j}$ 是卖了 $i \\sim j$ 的糖的最大收益。$dp_{i, j}$ 可以从 $dp_{i + 1, j} + \\footnotesize \\texttt{陈年时间} \\normalsize \\times a_i$ 和 $dp_{i, j - 1} + \\footnotesize \\texttt{陈年时间} \\normalsize \\times a_j$ 转移过来，陈年时间是 $n - \\text{len} - 1$（其中 $\\text{len}$ 是区间长度），因为每次卖糖都会减少陈年时间。\n#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;constexpr int NR = 2e3 + 5;int n, a[NR];ll dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        dp[i][i] = (ll)a[i] * n; // 区间长度为 1 时，卖掉唯一的糖果，陈年时间为 n    &#125;    for (int len = 2; len &lt;= n; ++ len) &#123;        for (int i = 1; i + len - 1 &lt;= n; ++ i) &#123;            int j = i + len - 1, now = n - len + 1; // 计算右端点和陈年时间            dp[i][j] = max(dp[i + 1][j] + (ll)a[i] * now, dp[i][j - 1] + (ll)a[j] * now);            // 转移        &#125;    &#125;    cout &lt;&lt; dp[1][n];    return 0;&#125;\n","categories":["总结"],"tags":["YL总结","算法"]},{"title":"20251008国庆联考day4","url":"/blog/20251008%E5%9B%BD%E5%BA%86%E8%81%94%E8%80%83day4/","content":"\n\n\n\nT1\nT2\nT3\nT4\n总分\n\n\n\n预估\n100\n100\n100\n100\n400\n\n\n实际\n100\n80\n90\n100\n370\n\n\nT1 - xor答案即为$$\\sum_{i&#x3D;1}^{n} a_i + \\max_{i&#x3D;1}^{n} [(a_i \\oplus k) - a_i]$$\nT2 - change两种方案：\n\n用第一种操作把首位加到 9，再把后面的第一个非 9 数位用第二种操作加一；\n用第一种操作把首位加到 8，再把首位用第二种操作加一；\n\n取较大值为答案。\nT3 - divide首先对 $b$ 数组取一个后缀最小值数组 $c$，再用类似埃氏筛的写法把 $c_i \\gets \\min (c_i, c_x + c_y)$，其中满足 $x \\times y &#x3D; i$，现在 $c_i$ 表示让一个数 $\\times i$ 的。\n对于每一个询问 $(x, y)$，可以二分求出最小的满足 $\\lfloor \\dfrac{x}{p} \\rfloor \\le y$ 的 $p$，答案为 $c_p$（注意要特 $x \\le y$，答案为 $0$）。\nT4 - structure很简单，对于每一个位置 $i$，求出每一个字母 $c$ 到现在为止出现的最后一次的位置（记为 $l_c$，没有则为 $0$）和倒数第二次出现的位置（记为 $l’_c$，没有则为 $0$）（$1 \\sim n$ 遍历过来可以线性求），那么对于这个位置，$[l’_c + 1, i], [l’_c + 2, i], \\dots, [l_c, i]$ 这 $l_c - l’_c$ 个区间（左端点为 $[l’_c + 1, l_c]$）都是只有一个 $c$，均为“坏子串”。\n对 26 个区间 $[l’_c + 1, l_c]$ 求并集，即为以 $i$ 为右端点的“坏子串”个数，求和即为答案。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"平面几何","url":"/blog/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/","content":"概念维度定义：一组相互独立的属性的数量。\n任意维度的取值与其他维度无关，比如二维空间里，$x$ 轴的取值与 $y$ 轴的取值无关，$y$ 轴的取值与 $x$ 轴的取值也无关。\n比如我们生活在三维空间里，而你正在看一篇在二维屏幕上显示的博客。\n点：可以看作零维；线：一维载体；面：二维载体；体：三维载体。\n坐标系坐标系是对点进行定位的规则，常见的有直角坐标系和极坐标系，一般&#x2F;默认是直角坐标系。\n直角坐标系\n\n将所有维度都为 $0$ 的点成为原点，用 $O$ 表示。\n\n将水平穿过原点的直线称为 $x$ 轴，左小右大；将竖直穿过原点的直线称为 $y$ 轴，下小上大。\n\n点的坐标 $(x, y)$ 就是这个点相对于原点在两轴上的偏移量。\n\n每一个维度的表示是等价的，置换维度不改变形状。\n\n\n极坐标系\n\n将所有维度都为 $0$ 的点成为极点，也用 $O$ 表示。\n\n将极点向右的水平射线称为极轴，作为旋转角的起点。\n\n点的坐标 $(r, \\theta)$ 由极径 $r$（该点到极点的距离）和极角 $\\theta$（由极轴逆时针转到极径的角度）表示。\n\n\n向量拥有大小和方向的量，也称矢量，是相对于标量而言的，标量是只有大小，没有方向的量，比如你的的体重就是标量 没有人的体重是向北的 60kg 吧，而物理中的力就用向量表示，因为力有方向，也有大小。\n向量可以用 $A$ 到 $B$ 的有向线段 $\\overrightarrow{AB}$ 表示，他的长度&#x2F;大小叫做向量的模，记作 $|AB|$。\n长度为零的向量被称为零向量，是唯一方向不确定的向量。长度为一的向量则被称为单位向量，与 $v$ 方向相同的单位向量称为 $v$ 的单位向量，记作 $v^0$。\n两个向量 $a$，$b$ 的夹角表示为 $\\lang a, b \\rang$（以 $a$ 为始边）。\n注意，向量没有位置属性，有向线段被平移后所表示的是同条向量。因此可以把有向线段的起点平移到原点，则终点就可以表示一个向量，此时终点的坐标就是原来有向线段两端的坐标差组成。比如下图，$\\overrightarrow{AB} \\longrightarrow \\overrightarrow{OC}$，则这两个向量都可以用 $(5,4)$ 表示。\n\n运算这里，向量都是用终点的坐标表示。\n加法\n把每一个维度的数值分别相加即可，若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OC} &#x3D; (x_1 + x_2, y_1 + y_2)$，。\n向量加法也满足交换律，即 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OB} + \\overrightarrow{OA} &#x3D; \\overrightarrow{OC}$。\n这里有衍生出一个概念，叫反向量，若 $\\overrightarrow{OP} &#x3D; (x, y)$，则其反向量 $\\overrightarrow{OQ} &#x3D; (-x, -y)$，满足 $\\overrightarrow{OP} + \\overrightarrow{OQ} &#x3D; (0, 0)$。\n减法加法的逆运算，两个维度分别相减即可。\n向量的加减运算称为平行四边形法则。\n点乘点乘符号为 $\\cdot$，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\cos \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 在 $\\overrightarrow{OA}$ 上投影的长度，是一个标量。比如在下图中，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; OA \\times OC$。\n\n计算方法 （当然，如果你想用定义去算的话也不是不可以）：若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; x_1 \\times x_2 + y_1 \\times y_2$。\n向量点乘满足交换律，可以用来判断向量的前后关系，如果对于两个向量 $a, b$，若 $a \\cdot b &#x3D; 0$，则 $\\lang a, b \\rang &#x3D; 90^\\circ$；若 $a \\cdot b &gt; 0$，则 $\\lang a, b \\rang &lt; 90^\\circ$；若 $a \\cdot b &lt; 0$，则 $\\lang a, b \\rang &gt; 90^\\circ$。\n叉乘叉乘符号为 $\\times$，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\sin \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 对于 $\\overrightarrow{OA}$ 上高的长度，也是一个标量。还是那上面那张图举例，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; OA \\times BC$，也就是以 $OA$ 和 $OB$ 为两边的平行四边形的面积（如果 $\\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang &lt; 0^\\circ$，则要取绝对值）。\n向量点乘不满足交换律（会变负），可以用来判断向量的左右关系，如果对于两个向量 $a, b$，若 $a \\times b &#x3D; 0$，则 $a$，$b$ 共线；若 $a \\times b &gt; 0$，则 $\\lang a, b \\rang &gt; 0^\\circ$；若 $a \\times b &lt; 0$，则 $\\lang a, b \\rang &lt; 0^\\circ$。\n例题&#x2F;应用洛谷 B2031 计算三角形面积可以发现是红题，也可以发现可以用海伦公式做\n直接对两边用叉乘取绝对值在除以二（$S_▱ \\div 2 &#x3D; S_\\triangle$）。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    double x, y;&#125;;constexpr int NR = 5;node p[NR];node mv(node x, node y) &#123; // make vector    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;double x_mul(node x, node y) &#123; // 叉乘    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    cin &gt;&gt; p[1].x &gt;&gt; p[1].y &gt;&gt; p[2].x &gt;&gt; p[2].y &gt;&gt; p[3].x &gt;&gt; p[3].y;    printf(&quot;%.2lf&quot;, abs(x_mul(mv(p[1], p[2]), mv(p[2], p[3]))) / (double)2.0);    return 0;&#125;\n\n洛谷 P1863 独眼兔每次选最右边的即可。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e3 + 5;int n, id = 1, vis[NR], nxt, tmp;node p[NR];node mv(node x, node y) &#123; // x --&gt; y    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int dis(node x, node y) &#123;    return (x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y);&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;        if (p[i].y &lt; p[id].y) id = i;    &#125;    vis[id] = 1;    cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    for (int T = n - 1; T --;) &#123;        nxt = -1;        for (int i = 1; i &lt;= n; ++ i) &#123;            if (vis[i]) continue;            if (nxt == -1) &#123;                nxt = i;                continue;            &#125;            tmp = x_mul(mv(p[id], p[nxt]), mv(p[nxt], p[i]));            if (tmp &lt; 0 || (tmp == 0 &amp;&amp; dis(p[id], p[nxt]) &gt; dis(p[id], p[i]))) nxt = i;        &#125;        id = nxt;        vis[id] = 1;        cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n洛谷 T269230 极角排序极角就是极坐标系里极径与极轴的夹角，分上下两部分，先按上下，同一边的用叉乘判断。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e5 + 5;int n, tmp;node p[NR];int find(node x) &#123;    if (x.y &gt;= 0) return 1;    return 2;&#125;int dis(node x) &#123;    return x.x * x.x + x.y * x.y;&#125;node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        if (find(x) != find(y)) return find(x) &lt; find(y);        tmp = x_mul(mv(&#123;0, 0&#125;, x), mv(&#123;0, 0&#125;, y));        if (tmp) return tmp &gt; 0;        return dis(x) &lt; dis(y);    &#125;);    for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n洛谷 P1142 轰炸我用的 DP，$dp_{i, j}$ 便是包含了第 $i$ 个和第 $j$ 个的线包含的点数。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 7e2 + 5;int n, dp[NR][NR], ans;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        return x.x &lt; y.x;    &#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) dp[i][j] = 2;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) &#123;            for (int k = 1; k &lt; i; ++ k) &#123;                if (x_mul(mv(p[k], p[i]), mv(p[i], p[j])) == 0) dp[i][j] = max(dp[i][j], dp[k][i] + 1);            &#125;            ans = max(ans, dp[i][j]);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\n洛谷 P1355 神秘大三角直接判断就好了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        char ch;        cin &gt;&gt; ch &gt;&gt; x &gt;&gt; ch &gt;&gt; y &gt;&gt; ch;        return;    &#125;&#125;;constexpr int NR = 5;int tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    for (int i = 1; i &lt;= 4; ++ i) p[i].read();    for (int i = 1; i &lt;= 3; ++ i) &#123;        int j = i + 1;        if (j == 4) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[4]));        if (tmp == 0) cnt0 ++;        else if (tmp &gt; 0) cnt1 ++;        else cnt_1 ++;    &#125;    if (cnt1 == 3 || cnt_1 == 3) cout &lt;&lt; 1;    else if (cnt0 == 1 &amp;&amp; (cnt1 == 2 || cnt_1 == 2)) cout &lt;&lt; 3;    else if (cnt0 == 2) cout &lt;&lt; 4;    else cout &lt;&lt; 2;    return 0;&#125;\n\n洛谷 P1183 多边形的面积\n把每个加起来就可以了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        cin &gt;&gt; x &gt;&gt; y;        return;    &#125;&#125;;constexpr int NR = 1e2 + 5;int n, tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;long long ans;int main() &#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) p[i].read();    for (int i = 1; i &lt;= n; ++ i) &#123;        int j = i + 1;        if (j == n + 1) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[0]));        ans += tmp;    &#125;    cout &lt;&lt; ans / 2;    return 0;&#125;","categories":["总结"],"tags":["YL总结","概念"]},{"title":"并查集","url":"/blog/%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集并查集，顾名思义就是可以合并两个集合、查询两个元素在不在同一个集合的数据结构。并查集用森林维护，记录每一个节点的父节点，如果是一棵树的根节点他的父节点就记为他自己。\n\n初始值：每一个节点的父节点都设为自己（每一个节点都是一棵单独的树）；\n合并节点 $x$、$y$ 所在的集合：找到 $x$、$y$ 的根节点 $f_x$、$f_y$，如果 $f_x &#x3D; f_y$，则 $x$ 和 $y$ 原本就在同一个集合，否则就令 $f_x$ 的父节点为 $f_y$（把 $f_x$ 的树合并到 $f_y$ 所在的树）；\n查询节点 $x$、$y$ 在不在同一个集合：找到 $x$、$y$ 的根节点 $f_x$、$f_y$，如果 $f_x &#x3D; f_y$，则 $x$ 和 $y$ 在同一个集合，否则不同。\n\n朴素实现：\nstruct DSU &#123;    int n, f[NR]; // f[x]: x 的父节点    DSU(int _n) : n(_n) &#123;        for (int i = 0; i &lt;= n; ++ i)            f[i] = i; // 初始时每一个节点的父节点都设为自己    &#125;    int find(int x) &#123; // 暴力找父节点        if (f[x] == x)            return x;        return find(f[x]);     &#125;    bool un(int x, int y) &#123; // 合并节点 x、y 所在的集合        x = find(x), y = find(y);        if (x == y)            return 0; // 原本就在同一个集合，无需合并        f[x] = y;        return 1; // 合并成功    &#125;    bool same(int x, int y) &#123; // 查询节点 x、y 在不在同一个集合        return find(x) == find(y);    &#125;&#125;;\n\n可是这样一次 find 的复杂度可能达到 $\\mathcal{O(n)}$，用这个写题就 T 飞了，考虑优化。\n注意到一般情况下我们只需要知道每一个节点的根节点是谁，不用关心他的父节点、父节点的父节点，于是可以直接把每一个节点的父节点设为根节点，这样就可以大大降低时间复杂度。\nint find(int x) &#123;    if (f[x] == x)        return x;    return f[x]/*直接设为根节点*/ = find(f[x]);&#125;\n\n我们还可以想到尽量把小的集合合并到大的集合，即启发式合并：\nstruct DSU &#123;    int n, f[NR], cnt[NR]; // cnt[x]：x 所在集合的大小    DSU(int _n) : n(_n) &#123;        for (int i = 0; i &lt;= n; ++ i) &#123;            f[i] = i;            cnt[i] = 1; // 最开始只有自己        &#125;    &#125;    int find(int x) &#123;        if (f[x] == x)            return x;        return f[x] = find(f[x]);    &#125;    bool un(int x, int y) &#123;        x = find(x), y = find(y);        if (x == y)            return 0;        if (cnt[x] &gt; cnt[y]) // 保证 x 更小            swap(x, y);        f[x] = y;        cnt[y] += cnt[x];        cnt[x] = cnt[y];        return 1;    &#125;    bool same(int x, int y) &#123;        return find(x) == find(y);    &#125;&#125;;\n\n这样一次 find 的时间复杂度均摊下来就是 $\\mathcal{O(\\alpha(n))}$ 了（当 $n$ 在可输入范围内，$\\mathcal{O(\\alpha(n))} \\leq 4$）。\n可撤销并查集有时候并查集还需要撤销最后的一些操作（比如线段树分治），这就需要用到可撤销并查集了。\n可撤销并查集就是用栈记录每一次操作，可以撤销最后一次操作。\n\n$\n\\newcommand\\BorderRect[4]{ \\color{#3}\\rule{#1}{#2}\\kern{-#1} \\color{#4}\\rule{0.5px}{#2}\\kern{-0.5px} \\rule{#1}{0px}\\rule{0.5px}{#2}\\kern{-0.5px} \\kern{-#1}\\rule[#2]{#1}{0px} } \\newcommand\\BasicInfoBarFather[8]{ \\BorderRect{#1}{#2}{#5}{ghostwhite} \\kern{-#1} \\raisebox{#2}{ \\raisebox{-26pt}{ \\color{black}\\kern{-4px} \\raisebox{7px}{ \\color{#7}\\Huge{∙}\\kern{-1px} } \\raisebox{10.6px}{ \\kern{-20.2px} \\color{white}\\scriptsize\\textbf{#6} } \\kern{-7px}\\footnotesize \\raisebox{10.2px}{\\textbf{\\textsf{\\color{#8}#3}}}\\kern{2px} \\raisebox{10.2px}{\\textsf{#4}} } } }\\def\\BasicWarnBarColorFill{#FFF4CE}\\def\\BasicWarnBarColorIcon{#9D5D00}\\newcommand\\BasicWarnBar[5]{ \\BasicInfoBarFather{#1}{#2}{#3}{#4} {\\BasicWarnBarColorFill}{i}{\\BasicWarnBarColorIcon}{\\BasicWarnBarColorIcon} }  \n\\BasicWarnBar{235px}{26px}{注意：}{\\hspace{-.12cm}这时候不能用路径压缩了，不然还原不了原来的状态}{#000000}\n$****\n\n\nstruct DSU &#123;    int f[NR], dep[NR];    vector&lt;piii&lt;int, int, int&gt; &gt; st; // 记录每一次合并的栈    DSU(int _n) : n(_n) &#123;        for (int i = 0; i &lt;= n; ++ i) &#123;            f[i] = i;            dep[i] = 1; // 这里用的按秩合并，深度小集合的合并到深度大的集合        &#125;    &#125;    int find(int x) &#123;        if (f[x] == x)            return x;        return find(f[x]);    &#125;    bool un(int u, int v) &#123;        u = find(u);        v = find(v);        if (u == v)            return false;        if (dep[u] &gt; dep[v]) // 保证 u 的深度较小            swap(u, v);        f[u] = v;        st.emplace_back(u, v, dep[v]); // 记录每一次合并        dep[v] = max(dep[v], dep[u] + 1); // 更新深度        return true;    &#125;    bool same(int x, int y) &#123;        return find(x) == find(y);    &#125;    void era() &#123;        auto [u, v, d] = st.back();        st.pop_back();        f[u] = u; // 还原成原来的根节点        dep[v] = d; // 原来的深度    &#125;&#125;\n\n例题洛谷 P3367【模板】并查集模版\nvoid solve() &#123;    cin &gt;&gt; n &gt;&gt; m;    DSU d(n);    while (m --) &#123;        int op, x, y;        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;        if (op == 1)            d.un(x, y);        else            cout &lt;&lt; (d.same(x, y) ? &#x27;Y&#x27; : &#x27;N&#x27;) &lt;&lt; &#x27;\\n&#x27;;    &#125;&#125;\n\n洛谷 P14077 [GESP202509 七级] 连通图把所有的边连起来后，连通块的个数 $-1$ 即为要加的边数。\nvoid solve() &#123;    cin &gt;&gt; n &gt;&gt; m;    DSU d(n);    while (m --) &#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        d.un(x, y);    &#125;    int ans = 0;    for (int i = 1; i &lt;= n; ++ i)        ans += (d.f[i] == i);    cout &lt;&lt; ans - 1 &lt;&lt; &#x27;\\n&#x27;;&#125;\n\n洛谷 P1396 营救按照每条边的边权从小到大排序，依次加入每一条边，直到 $s$ 与 $t$ 连通，答案就是当前边的边权。\nvoid solve() &#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;    for (int i = 1; i &lt;= m; ++ i)        cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;    sort(a + 1, a + m + 1, [](auto x, auto y) &#123;        return x.c &lt; y.c;    &#125;);    DSU d(n);    for (int i = 1; i &lt;= m; ++ i) &#123;        d.un(a[i].a, a[i].b);        if (d.find(s) == d.find(t)) &#123;            cout &lt;&lt; a[i].c &lt;&lt; &#x27;\\n&#x27;;            return;        &#125;    &#125;&#125;\n\n洛谷 P1525 [NOIP 2010 提高组] 关押罪犯根据题意，尽量把怨气值大的两个罪犯尽量分开，即分在两个不同的监狱里，那这就要用到拓展域并查集了。\n拓展域并查集就是给每一个点多个状态，本题中就是对于第 $i$ 个罪犯，他在第一个监狱的状态就是 $i$，在第二个监狱的状态就是 $i + n$。那两个罪犯 $i$、$j$ 分到两个不同监狱就是合并 $(i, j + n)$ 和 $(i + n, j)$。如果到哪一对罪犯，他们在同一个监狱的状态在同一个连通块了，就不可能再分开了。\nvoid solve() &#123;    cin &gt;&gt; n &gt;&gt; m;    DSU d(n &lt;&lt; 1);    for (int i = 1; i &lt;= m; ++ i)        cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;    sort(a + 1, a + m + 1, [](auto x, auto y) &#123;        return x.c &gt; y.c;    &#125;); // 按照怨气值从大到小排序，优先分开怨气值大的    for (int i = 1; i &lt;= m; ++ i) &#123;        if (d.find(a[i].a) == d.find(a[i].b)) &#123; // 分不开了            cout &lt;&lt; a[i].c &lt;&lt; &#x27;\\n&#x27;;            return;        &#125;        d.un(a[i].a, a[i].b + n);        d.un(a[i].a + n, a[i].b);    &#125;    cout &lt;&lt; &quot;0\\n&quot;; // 注意要输出 0&#125;","categories":["总结"],"tags":["YL总结","算法"]},{"title":"搜索","url":"/blog/%E6%90%9C%E7%B4%A2/","content":"$\\texttt{1.}$DFS\n不撞南墙不回头\n\nDFS 的特点就是“一条路走到黑，撞南墙了再回头”，每次递归调用都尝试向一个方向前进，如果遇到障碍，则回溯到上一个节点，尝试其他方向。所以 DFS 一般使用递归实现。\n模板（一维）：\nvoid dfs(int x) &#123;    if (/*x 超出范围*/) &#123;        // 统计/输出结果        return;    &#125;    for (/*所有可能的后继状态*/) &#123;        if (/*x 和 i 不符合条件*/) &#123;            continue;        &#125;        // 标记 x 和 i 的关系        dfs(i);        // 撤销标记    &#125;    return;&#125;\n\n$\\texttt{2.}$BFSBFS 的特点就是“先搜最近的，再搜远的”，每次选出离起点最近的状态，遍历所有可能的后继状态，再把后继状态加进待选的集合中。所以 BFS 一般使用队列实现。在等&#x2F;无权图中，第一次找到的路径长度就是最短路。\n模板（一维）：\nvoid bfs(int s) &#123;    queue&lt;int&gt; q;    q.push(s);    // 清空标记、最短路数组    while (!q.empty()) &#123;        int x = q.front();        q.pop();        for (/*所有可能的后继状态*/) &#123;            if (/*不符合条件*/) continue;            // 标记            q.push(/*后继状态*/);        &#125;    &#125;    return;&#125;\n\n01BFS边权只有 0 或 1（0 或一个固定值）的图中的最短路，可以用双端队列实现，每次把 0 的边权节点放到队头，把 1 的边权节点放到队尾，这样每次取到的都是当前最短路节点，其实本质上是 Dijkstra。\n$\\texttt{3.}$例题A$\\texttt.$ 洛谷 P1706 全排列问题DFS，每次只可以选之前没有选过的数字，所以用数组标记一下即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e1;int n, p[NR], f[NR];// p 数组存储排列，f 数组标记数字是否被选过void dfs(int x) &#123;    if (x &gt; n) &#123;        for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; &quot;    &quot; &lt;&lt; p[i];        cout &lt;&lt; &#x27;\\n&#x27;;        // 输出排列        return;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        if (f[i]) continue;        f[i] = 1;        p[x] = i;        // 标记        dfs(x + 1);        f[i] = 0;        // 撤销标记    &#125;    return;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    dfs(1);    return 0;&#125;\n\nD$\\texttt.$ 洛谷 P1746 离开中山路BFS，每次向上下左右四个方向扩展，不能到店铺里，直到找到终点。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e3 + 5;int n, dis[NR][NR], vis[NR][NR], ans;bool a[NR][NR];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;// 方向数组int sx, sy, ex, ey;int bfs() &#123;    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(&#123;sx, sy&#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            dis[i][j] = INT_MAX;            vis[i][j] = 0;        &#125;    &#125;    dis[sx][sy] = 0;    vis[sx][sy] = 1;    while (!q.empty()) &#123;        int tx = q.front().first, ty = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; ++ i) &#123;            int nx = tx + dx[i], ny = ty + dy[i];            if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; n) continue;            // 超出范围            if (vis[nx][ny] || a[nx][ny]) continue;            // 已经访问过或者到店铺里            dis[nx][ny] = dis[tx][ty] + 1;            vis[nx][ny] = 1;            if (nx == ex &amp;&amp; ny == ey) return dis[nx][ny];            // 到达终点，返回答案            q.push(&#123;nx, ny&#125;);        &#125;    &#125;    return -1;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            char ch;            cin &gt;&gt; ch;            a[i][j] = ch - &#x27;0&#x27;;        &#125;    &#125;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;    cout &lt;&lt; bfs();    return 0;&#125;\n\n","categories":["总结"],"tags":["YL总结","算法"]},{"title":"线性DP","url":"/blog/%E7%BA%BF%E6%80%A7DP/","content":"线性 $\\texttt{DP}$所有 $\\texttt{DP}$ 都要满足的条件：\n\n最优子结构：即动规中的 状态，可以同归一些状态推出它的后继状态，最终求出答案。\n重叠子问题：即子问题之间有重复计算的部分，可以用一个数组记录下来，避免重复计算。\n无后效性：已经确定的状态，不会因为后续状态的变化而变化。\n\n线性 $\\texttt{DP}$ 是一类状态定义与题目条件线性相关的 $\\texttt{DP}$：如果题目给定一个一味的序列，要你求最大&#x2F;最小&#x2F;个数&#x2F;概率等，那么 $\\texttt{dp}$ 状态就是一维的，如果是二维棋盘上的问题，那么 $\\texttt{dp}$ 状态就是二维的。\n例题洛谷 P5146 最大差值好吧，也不知道为什么这题会要 $\\texttt{dp}$，一个变量就好了，题目要求：$$\\max_{1 \\leq i &lt; j \\leq n} {a_j - a_i}$$\n用一个变量存到当前位置的最小值，然后每次更新答案即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;long long n, a, minn = LONG_LONG_MAX, ans = LONG_LONG_MIN;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    while (n --) &#123;        cin &gt;&gt; a;        if (minn &gt;= 1e17) minn = a;        else &#123;            ans = max(ans, a - minn);            minn = min(minn, a);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nAtcoder Tessoku Book DP a - Frog 1真正的线性 $\\texttt{dp}$，设 $dp_i$ 为到达第 $i$ 个石头所需要的最小花费，则对于 $i \\geq 3$，$dp_i &#x3D; \\min(dp_{i - 1} + |a_i - a_{i - 1}|, dp_{i - 2} + |a_i - a_{i - 2}|)$，$dp_1 &#x3D; 0$，$dp_2 &#x3D; |a_2 - a_1|$，最后答案就是 $dp_n$。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e5 + 5;int n, a[NR], dp[NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    memset(dp, 0x3f, sizeof dp);    dp[1] = 0;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; a[i];        if (i == 2) &#123;            dp[i] = abs(a[2] - a[1]);        &#125;        else if (i &gt; 2) dp[i] = min(dp[i - 1] + abs(a[i] - a[i - 1]), dp[i - 2] + abs(a[i] - a[i - 2]));    &#125;    cout &lt;&lt; dp[n];    return 0;&#125;\n\nAtcoder DP F - LCS最长公共子序列，设 $dp_{i, j}$ 表示 $s_{1 \\sim i}$ 和 $t_{1 \\sim j}$ 的 $\\texttt{LCS}$ 的长度，则对于 $i, j \\geq 1$，$dp_{i, j} &#x3D; \\max(dp_{i - 1, j}, dp_{i, j - 1}, dp_{i - 1, j - 1} + [s_i &#x3D; t_j])$，$\\texttt{LCS}$ 长度就是 $dp_{n, m}$，再从 $(n, m)$ 往回反推所有状态。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e3 + 5;string s, t;int n, m, dp[NR][NR];int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; s &gt;&gt; t;    n = s.size(); // 记录长度    m = t.size();    s = &#x27;\\0&#x27; + s; // 为了方便，从 1 开始编号    t = &#x27;\\0&#x27; + t;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= m; ++ j) &#123;            if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1;            dp[i][j] = max(&#123;dp[i][j], dp[i - 1][j], dp[i][j - 1]&#125;);        &#125;    &#125;    string ans = &quot;&quot;;    int x = n, y = m; // 当前在 dp[i][j]，从 (n, m) 开始反推    while (ans.size() &lt; dp[n][m]) &#123;        if (s[x] == t[y] &amp;&amp; dp[x][y] == dp[x - 1][y - 1] + 1) &#123;            // 如果当前字符相等，并且 dp[x][y] = dp[x - 1][y - 1] + 1，说明这个字符是公共的            ans = s[x] + ans; // 将这个字符加到答案的开头            x --;            y --;        &#125;        else if (x &gt; 0 &amp;&amp; dp[x][y] == dp[x - 1][y]) x --; // 其他情况        else y --;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\nAtcoder ABC410 E - Battles in a Row设 $dp_{i, j}$ 表示魔法值用了 $i$，生命值用了 $j$ 时打败的最多的怪物的数量，答案就是$$\\max_{1 \\leq i \\leq h, 1 \\leq j \\leq m} {dp_{i, j}}$$，转移详见代码。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 3e3 + 5;int n, h, m, a[NR], b[NR], dp[NR][NR], ans;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n &gt;&gt; h &gt;&gt; m;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i] &gt;&gt; b[i];    memset(dp, -1, sizeof dp);    dp[0][0] = 0;    for (int i = 0; i &lt;= h; ++ i) &#123;        for (int j = 0; j &lt;= m; ++ j) &#123;            if (dp[i][j] == -1) continue;            int pos = dp[i][j] + 1; // 现在要打的怪物            ans = max(ans, dp[i][j]); //顺便统计答案            if (a[pos] + i &lt;= h) dp[i + a[pos]][j] = max(dp[i + a[pos]][j], pos); // 用魔法值            if (b[pos] + j &lt;= m) dp[i][j + b[pos]] = max(dp[i][j + b[pos]], pos); // 用生命值        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;","categories":["总结"],"tags":["YL总结","算法"]},{"title":"树上启发式合并","url":"/blog/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","content":"树上启发式合并（$\\text{DSU on tree}$）$\\text{DSU on tree}$ 跟并查集没有半毛钱关系，只是因为其合并策略借鉴了并查集中“按秩合并”或“启发式合并”的思想而已。\n基本思想先看一道例题：CF600E Lomsat gelral\n题意大致就是给一棵以 $1$ 为根树，每一个节点有一个权值，求出对于每一个节点他的子树内的所有节点权值的众数的和。\n首先暴力，对于每一个节点遍历它的子树，统计权值出现次数，然后求出众数，最后统计答案。时间复杂度 $\\mathcal O(n ^ 2)$。\n考虑优化，对于每一个节点，他可以继承他的任意一个子节点的信息，再把其他子节点再加进去，就可以求出这个节点的答案了。如果我们每一个节点都继承他的子树中节点个数最多的子树的信息，那么时间复杂度就是 $\\mathcal O(n \\log n)$。\n\n\n时间复杂度证明\n\n\n$\\text{DSU on tree}$ 中，每个节点仅在其所在子树作为轻儿子被遍历时才会被暴力加入统计结构。由于从任意节点到根的路径上轻边数量不超过 $\\log n$（每次经过轻边，子树大小至少减半，不然就是重儿子），因此每个节点至多被处理 $\\mathcal O(\\log n)$ 次。因此总时间复杂度为 $\\mathcal O(n \\log n)$。\n\n\n具体实现int n, c[NR]; // c[i] 表示节点 i 的权值vector&lt;int&gt; g[NR]; // 邻接表存树int sz[NR], mxson[NR];void dfs_mxson(int x, int l) &#123; // 处理出每一个节点的重儿子    sz[x] = 1; // 子树结点个数    for (int i : g[x]) &#123;        if (i == l)            continue;        dfs_mxson(i, x);        sz[x] += sz[i];        if (sz[mxson[x]] &lt; sz[i])            mxson[x] = i; // 更新重儿子    &#125;&#125;int cnt[NR], mx; // cnt 表示权值出现次数，mx 表示出现次数最多的权值ll sum; // sum 表示出现次数最多的权值之和void count(int x, int l, int v) &#123;    cnt[c[x]] += v; // 增加或减少权值出现次数    if (cnt[c[x]] &gt; cnt[mx] || mx == c[x])        mx = sum = c[x]; // 更新众数    else if (cnt[c[x]] == cnt[mx])        sum += c[x]; // 更新众数之和    if (l == -1) // 如果 l == -1，说明是单次节点，直接返回        return;    for (int i : g[x]) &#123;        if (i == l)            continue;        count(i, x, v); // 继续数子节点    &#125;&#125;ll ans[NR]; // 记录每一个结点的答案void dfs(int x, int l, bool k) &#123; // k 表示要不要清空这个子树    for (int i : g[x]) &#123;        if (i == l || i == mxson[x]) // 跳过重儿子            continue;        dfs(i, x, false); // 需要清空    &#125;    if (mxson[x]) // 如果存在重儿子（叶节点没有）        dfs(mxson[x], x, true); // 要保留重儿子的信息    for (int i : g[x]) &#123;        if (i == l || i == mxson[x])            continue;        count(i, x, true); // 统计答案，要用 count，不然时间复杂度就错了    &#125;    count(x, -1, 1); // 只加入 x 一个节点    ans[x] = sum; // 记录答案    if (!k) // 如果不需要保留重儿子的信息，就清空        count(x, l, -1);&#125;void solve() &#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i)        cin &gt;&gt; c[i]; // 读入权值    for (int i = 1; i &lt; n; ++ i) &#123;        int u, v;        cin &gt;&gt; u &gt;&gt; v; // 读入边        g[u].emplace_back(v);        g[v].emplace_back(u);    &#125;    dfs_mxson(1, 0); // 处理出重儿子    dfs(1, 0, 0); // 处理答案    for (int i = 1; i &lt;= n; ++ i)        cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; // 输出答案&#125;\n\n例题洛谷 P9233 [蓝桥杯 2023 省 A] 颜色平衡树几乎和上面一样，只需要把 $\\text{sum}$ 从记录众数的权值和改为众数权值个数之和即可，输出时判断 $\\text{ans[i]}$ 是否是他的子树大小即可（全部都是众数代表每个权值的个数都相等）。\nint n, c[NR];vector&lt;int&gt; g[NR];int sz[NR], mxson[NR];void dfs_mxson(int x, int l) &#123;    sz[x] = 1;    for (int i : g[x]) &#123;        if (i == l)            continue;        dfs_mxson(i, x);        sz[x] += sz[i];        if (sz[mxson[x]] &lt; sz[i])            mxson[x] = i;    &#125;&#125;int cnt[NR], mx;ll sum;void count(int x, int l, int v) &#123;    cnt[c[x]] += v;    if (cnt[c[x]] &gt; cnt[mx] || mx == c[x]) &#123;        mx = c[x];        sum = cnt[mx]; // 加上的是众数的个数    &#125; else if (cnt[c[x]] == cnt[mx])        sum += cnt[c[x]];    if (l == -1)        return;    for (int i : g[x]) &#123;        if (i == l)            continue;        count(i, x, v);    &#125;&#125;ll res[NR];void dfs(int x, int l, bool k) &#123;    for (int i : g[x]) &#123;        if (i == l || i == mxson[x])            continue;        dfs(i, x, false);    &#125;    if (mxson[x])        dfs(mxson[x], x, true);    for (int i : g[x]) &#123;        if (i == l || i == mxson[x])            continue;        count(i, x, true);    &#125;    count(x, -1, 1);    res[x] = sum;    if (!k)        count(x, l, -1);&#125;void solve() &#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        int f;        cin &gt;&gt; c[i] &gt;&gt; f;        if (f) &#123;            g[f].emplace_back(i);            g[i].emplace_back(f);        &#125;    &#125;    dfs_mxson(1, 0);    dfs(1, 0, 0);    int ans = 0;    for (int i = 1; i &lt;= n; ++ i)        ans += (sz[i] == res[i]); // 判断是否是子树大小    cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;\n\nCF570D Tree Requests回文串的要求就是每一个字母出现的个数是奇数的个数 $\\leq 1$。\n记录每一层每一个字母出现的次数以及每一层字母出现的个数是奇数的个数。如果奇数的个数 $\\leq 1$，那么就可以，否则不行。\nint n, m, c[NR];char a[NR];vector&lt;int&gt; g[NR];vector&lt;pii&lt;int, int&gt; &gt; q[NR];int sz[NR], mxson[NR];void dfs_mxson(int x, int l) &#123;    c[x] = c[l] + 1;    sz[x] = 1;    for (int i : g[x]) &#123;        if (i == l)            continue;        dfs_mxson(i, x);        sz[x] += sz[i];        if (sz[mxson[x]] &lt; sz[i])            mxson[x] = i;    &#125;&#125;int cnt[NR][30], co[NR]; // cnt 表示每一层每一个字母出现的次数，co 表示每一层字母出现的个数是奇数的个数ll sum;void count(int x, int l, int v) &#123;    cnt[c[x]][a[x] - &#x27;a&#x27;] += v; // 记录每一层每一个字母出现的次数    if (cnt[c[x]][a[x] - &#x27;a&#x27;] &amp; 1) // 变成奇数，奇数的个数 + 1        co[c[x]] ++;    else // 变成偶数，奇数的个数 - 1        co[c[x]] --;    if (l == -1)        return;    for (int i : g[x]) &#123;        if (i == l)            continue;        count(i, x, v);    &#125;&#125;bool ans[NR];void dfs(int x, int l, bool k) &#123;    for (int i : g[x]) &#123;        if (i == l || i == mxson[x])            continue;        dfs(i, x, false);    &#125;    if (mxson[x])        dfs(mxson[x], x, true);    for (int i : g[x]) &#123;        if (i == l || i == mxson[x])            continue;        count(i, x, true);    &#125;    count(x, -1, true);    for (auto [d, i] : q[x]) // 对于每一个查询，判断是否满足条件        ans[i] = co[d] &lt;= 1;    if (!k)        count(x, l, -1);&#125;void solve() &#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 2; i &lt;= n; ++ i) &#123;        int f;        cin &gt;&gt; f;        g[f].emplace_back(i);        g[i].emplace_back(f);    &#125;    for (int i = 1; i &lt;= n; ++ i)        cin &gt;&gt; a[i];    for (int i = 1; i &lt;= m; ++ i) &#123;        int u, v;        cin &gt;&gt; u &gt;&gt; v;        q[u].emplace_back(v, i); // 记录每一个查询    &#125;    dfs_mxson(1, 0);    dfs(1, 0, 0);    for (int i = 1; i &lt;= m; ++ i)        cout &lt;&lt; (ans[i] ? &quot;Yes\\n&quot; : &quot;No\\n&quot;);&#125;","categories":["总结"],"tags":["YL总结","算法"]},{"title":"20251005国庆联考day1","url":"/blog/20251005%E5%9B%BD%E5%BA%86%E8%81%94%E8%80%83day1/","content":"\n\n\n\nT1\nT2\nT3\nT4\n总分\n\n\n\n预估\n100\n100\n50\n0\n250\n\n\n实际\n100\n60\n50\n0\n210\n\n\nT1 - gold纯种诈骗，因为每个金币的时间限制都是不一样的，所以每一个都可以拿，直接取最大 $k$ 个。\nT2 - multiply让两数之差最小即可（注意要判前面相等的情况）。\nT3 - drink暴力模拟 50pts。\n正解，我们先来列个方程：\n$\\hspace{3.4cm} k \\footnotesize\\texttt{个空瓶} \\normalsize &#x3D; 1 \\footnotesize\\texttt{个空瓶} \\normalsize + 1 \\footnotesize\\texttt{瓶饮料}$\n$\\hspace{2.05cm} \\Leftrightarrow (k - 1) \\footnotesize\\texttt{个空瓶} \\normalsize &#x3D; 1 \\footnotesize\\texttt{瓶饮料} \\normalsize$\n于是，牛牛就可以喝到 $\\lfloor \\dfrac{n}{k - 1} \\rfloor$ 瓶饮料，写个高精除即可。\nT4 - surgery按照到来的时间排序，用 priority_queue 维护当前最紧急的人，每个人来之前把他前面能治的治了，再把他入队，统计所有的金币数的和即为答案。\n","categories":["总结"],"tags":["YL总结","考试"]}]