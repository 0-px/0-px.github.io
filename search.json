[{"title":"搜索","url":"/2025/09/01/%E6%90%9C%E7%B4%A2/","content":"$\\texttt{1.}$DFS\n不撞南墙不回头\n\nDFS 的特点就是“一条路走到黑，撞南墙了再回头”，每次递归调用都尝试向一个方向前进，如果遇到障碍，则回溯到上一个节点，尝试其他方向。所以 DFS 一般使用递归实现。\n模板（一维）：\nvoid dfs(int x) &#123;    if (/*x 超出范围*/) &#123;        // 统计/输出结果        return;    &#125;    for (/*所有可能的后继状态*/) &#123;        if (/*x 和 i 不符合条件*/) &#123;            continue;        &#125;        // 标记 x 和 i 的关系        dfs(i);        // 撤销标记    &#125;    return;&#125;\n\n$\\texttt{2.}$BFSBFS 的特点就是“先搜最近的，再搜远的”，每次选出离起点最近的状态，遍历所有可能的后继状态，再把后继状态加进待选的集合中。所以 BFS 一般使用队列实现。在等&#x2F;无权图中，第一次找到的路径长度就是最短路。\n模板（一维）：\nvoid bfs(int s) &#123;    queue&lt;int&gt; q;    q.push(s);    // 清空标记、最短路数组    while (!q.empty()) &#123;        int x = q.front();        q.pop();        for (/*所有可能的后继状态*/) &#123;            if (/*不符合条件*/) continue;            // 标记            q.push(/*后继状态*/);        &#125;    &#125;    return;&#125;\n\n01BFS边权只有 0 或 1（0 或一个固定值）的图中的最短路，可以用双端队列实现，每次把 0 的边权节点放到队头，把 1 的边权节点放到队尾，这样每次取到的都是当前最短路节点，其实本质上是 Dijkstra。\n$\\texttt{3.}$例题A$\\texttt.$ 洛谷 P1706 全排列问题DFS，每次只可以选之前没有选过的数字，所以用数组标记一下即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e1;int n, p[NR], f[NR];// p 数组存储排列，f 数组标记数字是否被选过void dfs(int x) &#123;    if (x &gt; n) &#123;        for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; &quot;    &quot; &lt;&lt; p[i];        cout &lt;&lt; &#x27;\\n&#x27;;        // 输出排列        return;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        if (f[i]) continue;        f[i] = 1;        p[x] = i;        // 标记        dfs(x + 1);        f[i] = 0;        // 撤销标记    &#125;    return;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    dfs(1);    return 0;&#125;\n\nD$\\texttt.$ 洛谷 P1746 离开中山路BFS，每次向上下左右四个方向扩展，不能到店铺里，直到找到终点。\n#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int NR = 1e3 + 5;int n, dis[NR][NR], vis[NR][NR], ans;bool a[NR][NR];int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;// 方向数组int sx, sy, ex, ey;int bfs() &#123;    queue&lt;pair&lt;int, int&gt; &gt; q;    q.push(&#123;sx, sy&#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            dis[i][j] = INT_MAX;            vis[i][j] = 0;        &#125;    &#125;    dis[sx][sy] = 0;    vis[sx][sy] = 1;    while (!q.empty()) &#123;        int tx = q.front().first, ty = q.front().second;        q.pop();        for (int i = 0; i &lt; 4; ++ i) &#123;            int nx = tx + dx[i], ny = ty + dy[i];            if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; n) continue;            // 超出范围            if (vis[nx][ny] || a[nx][ny]) continue;            // 已经访问过或者到店铺里            dis[nx][ny] = dis[tx][ty] + 1;            vis[nx][ny] = 1;            if (nx == ex &amp;&amp; ny == ey) return dis[nx][ny];            // 到达终点，返回答案            q.push(&#123;nx, ny&#125;);        &#125;    &#125;    return -1;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = 1; j &lt;= n; ++ j) &#123;            char ch;            cin &gt;&gt; ch;            a[i][j] = ch - &#x27;0&#x27;;        &#125;    &#125;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;    cout &lt;&lt; bfs();    return 0;&#125;\n\n","categories":["总结"],"tags":["YL总结","算法"]},{"title":"20250903第一次拔高训练","url":"/2025/09/09/20250903%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%94%E9%AB%98%E8%AE%AD%E7%BB%83/","content":"A\n如果 Alice 在两个奖品之间（包含两端），则不管 Bob 站在哪里都不可能离两个奖品都更近，输出 NO。\n\n否则 Alice 站在两个奖品的左边或右边，Bob 就可以站在比 Alice 更近的位置从而取胜，输出 YES。\n\n\nB交易次数最小的情况只有一种（$3$ 进制），直接算就好了。\n从左到右遍历，对与奇数位置，优先减右边的，如果减\nC直接模拟贪心，只需要保证对于每个偶数位，它两边的两个位置的和不大于它即可。\n从左到右遍历，对于每个位置，优先减右边，右边到零再减左边。\nD对于每个深度大于一的叶节点都要进行一次操作，找到答案最小的即可。\nE为什么会用记忆化搜索啊？\n直接模拟，如果碰到了和之前时间（$\\bmod ; k$）、位置、方向都一样的就进入循环了，不可能走出来，如果到了 $0$ 或 $n + 1$ 就走出来了。\nF前缀和 $+$ 指针，记录上次 $&gt;x$ 的位置。\n用 map 维护和区间。\n\n如果这个点比 $x$ 大，清空 map，指针指到现在的位置。\n如果这个点是 $x$，把 $(\\footnotesize \\texttt{指针位置} \\normalsize, \\footnotesize \\texttt{现在位置} \\normalsize]$ 的前缀和加到 map 里面，再给答案加上 $\\text{sum}_i - s$ 的个数。\n\n最后输出 $x$ 即可。\n","categories":["总结"],"tags":["YL总结","考试"]},{"title":"平面几何","url":"/2025/09/12/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/","content":"概念维度定义：一组相互独立的属性的数量。\n任意维度的取值与其他维度无关，比如二维空间里，$x$ 轴的取值与 $y$ 轴的取值无关，$y$ 轴的取值与 $x$ 轴的取值也无关。\n比如我们生活在三维空间里，而你正在看一篇在二维屏幕上显示的博客。\n点：可以看作零维；线：一维载体；面：二维载体；体：三维载体。\n坐标系坐标系是对点进行定位的规则，常见的有直角坐标系和极坐标系，一般&#x2F;默认是直角坐标系。\n直角坐标系\n\n将所有维度都为 $0$ 的点成为原点，用 $O$ 表示。\n\n将水平穿过原点的直线称为 $x$ 轴，左小右大；将竖直穿过原点的直线称为 $y$ 轴，下小上大。\n\n点的坐标 $(x, y)$ 就是这个点相对于原点在两轴上的偏移量。\n\n每一个维度的表示是等价的，置换维度不改变形状。\n\n\n极坐标系\n\n将所有维度都为 $0$ 的点成为极点，也用 $O$ 表示。\n\n将极点向右的水平射线称为极轴，作为旋转角的起点。\n\n点的坐标 $(r, \\theta)$ 由极径 $r$（该点到极点的距离）和极角 $\\theta$（由极轴逆时针转到极径的角度）表示。\n\n\n向量拥有大小和方向的量，也称矢量，是相对于标量而言的，标量是只有大小，没有方向的量，比如你的的体重就是标量 没有人的体重是向北的 60kg 吧，而物理中的力就用标量表示，因为力有方向，也有大小。\n向量可以用 $A$ 到 $B$ 的有向线段 $\\overrightarrow{AB}$ 表示，他的长度&#x2F;大小叫做向量的模，记作 $|AB|$。\n长度为零的向量被称为零向量，是唯一方向不确定的向量。长度为一的向量则被称为单位向量，与 $v$ 方向相同的单位向量称为 $v$ 的单位向量，记作 $v^0$。\n两个向量 $a$，$b$ 的夹角表示为 $\\lang a, b \\rang$（以 $a$ 为始边）。\n注意，向量没有位置属性，有向线段被平移后所表示的是同条向量。因此可以把有向线段的起点平移到原点，则终点就可以表示一个向量，此时终点的坐标就是原来有向线段两端的坐标差组成。比如下图，$\\overrightarrow{AB} \\longrightarrow \\overrightarrow{OC}$，则这两个向量都可以用 $(5,4)$ 表示。\n\n运算这里，向量都是用终点的坐标表示。\n加法\n把每一个维度的数值分别相加即可，若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OC} &#x3D; (x_1 + x_2, y_1 + y_2)$，。\n向量加法也满足交换律，即 $\\overrightarrow{OA} + \\overrightarrow{OB} &#x3D; \\overrightarrow{OB} + \\overrightarrow{OA} &#x3D; \\overrightarrow{OC}$。\n这里有衍生出一个概念，叫反向量，若 $\\overrightarrow{OP} &#x3D; (x, y)$，则其反向量 $\\overrightarrow{OQ} &#x3D; (-x, -y)$，满足 $\\overrightarrow{OP} + \\overrightarrow{OQ} &#x3D; (0, 0)$。\n减法加法的逆运算，两个维度分别相减即可。\n向量的加减运算称为平行四边形法则。\n点乘点乘符号为 $\\cdot$，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\cos \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 在 $\\overrightarrow{OA}$ 上投影的长度，是一个标量。比如在下图中，$\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; OA \\times OC$。\n\n计算方法 （当然，如果你想用定义去算的话也不是不可以）：若 $\\overrightarrow{OA} &#x3D; (x_1, y_1)$，$\\overrightarrow{OB} &#x3D; (x_2, y_2)$，则 $\\overrightarrow{OA} \\cdot \\overrightarrow{OB} &#x3D; x_1 \\times x_2 + y_1 \\times y_2$。\n向量点乘满足交换律，可以用来判断向量的前后关系，如果对于两个向量 $a, b$，若 $a \\cdot b &#x3D; 0$，则 $\\lang a, b \\rang &#x3D; 90^\\circ$；若 $a \\cdot b &gt; 0$，则 $\\lang a, b \\rang &lt; 90^\\circ$；若 $a \\cdot b &lt; 0$，则 $\\lang a, b \\rang &gt; 90^\\circ$。\n叉乘叉乘符号为 $\\times$，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; |\\overrightarrow{OA}| |\\overrightarrow{OB}| \\sin \\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang$，即 $|\\overrightarrow{OA}|$ 乘上 $\\overrightarrow{OB}$ 对于 $\\overrightarrow{OA}$ 上高的长度，也是一个标量。还是那上面那张图举例，$\\overrightarrow{OA} \\times \\overrightarrow{OB} &#x3D; OA \\times BC$，也就是以 $OA$ 和 $OB$ 为两边的平行四边形的面积（如果 $\\lang \\overrightarrow{OA}, \\overrightarrow{OB} \\rang &lt; 0^\\circ$，则要取绝对值）。\n向量点乘不满足交换律（会变负），可以用来判断向量的左右关系，如果对于两个向量 $a, b$，若 $a \\times b &#x3D; 0$，则 $a$，$b$ 共线；若 $a \\times b &gt; 0$，则 $\\lang a, b \\rang &gt; 0^\\circ$；若 $a \\times b &lt; 0$，则 $\\lang a, b \\rang &lt; 0^\\circ$。\n例题&#x2F;应用洛谷 B2031 计算三角形面积可以发现是红题，也可以发现可以用海伦公式做\n直接对两边用叉乘取绝对值在除以二（$S_▱ \\div 2 &#x3D; S_\\triangle$）。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    double x, y;&#125;;constexpr int NR = 5;node p[NR];node mv(node x, node y) &#123; // make vector    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;double x_mul(node x, node y) &#123; // 叉乘    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    cin &gt;&gt; p[1].x &gt;&gt; p[1].y &gt;&gt; p[2].x &gt;&gt; p[2].y &gt;&gt; p[3].x &gt;&gt; p[3].y;    printf(&quot;%.2lf&quot;, abs(x_mul(mv(p[1], p[2]), mv(p[2], p[3]))) / (double)2.0);    return 0;&#125;\n\n洛谷 P1863 独眼兔每次选最右边的即可。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e3 + 5;int n, id = 1, vis[NR], nxt, tmp;node p[NR];node mv(node x, node y) &#123; // x --&gt; y    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int dis(node x, node y) &#123;    return (x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y);&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;    for (int i = 1; i &lt;= n; ++ i) &#123;        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;        if (p[i].y &lt; p[id].y) id = i;    &#125;    vis[id] = 1;    cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    for (int T = n - 1; T --;) &#123;        nxt = -1;        for (int i = 1; i &lt;= n; ++ i) &#123;            if (vis[i]) continue;            if (nxt == -1) &#123;                nxt = i;                continue;            &#125;            tmp = x_mul(mv(p[id], p[nxt]), mv(p[nxt], p[i]));            if (tmp &lt; 0 || (tmp == 0 &amp;&amp; dis(p[id], p[nxt]) &gt; dis(p[id], p[i]))) nxt = i;        &#125;        id = nxt;        vis[id] = 1;        cout &lt;&lt; id &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n洛谷 T269230 极角排序极角就是极坐标系里极径与极轴的夹角，分上下两部分，先按上下，同一边的用叉乘判断。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 1e5 + 5;int n, tmp;node p[NR];int find(node x) &#123;    if (x.y &gt;= 0) return 1;    return 2;&#125;int dis(node x) &#123;    return x.x * x.x + x.y * x.y;&#125;node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        if (find(x) != find(y)) return find(x) &lt; find(y);        tmp = x_mul(mv(&#123;0, 0&#125;, x), mv(&#123;0, 0&#125;, y));        if (tmp) return tmp &gt; 0;        return dis(x) &lt; dis(y);    &#125;);    for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; p[i].x &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].y &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n洛谷 P1142 轰炸我用的 DP，$dp_{i, j}$ 便是包含了第 $i$ 个和第 $j$ 个的线包含的点数。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;&#125;;constexpr int NR = 7e2 + 5;int n, dp[NR][NR], ans;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y;    sort(p + 1, p + n + 1, [](node x, node y) &#123;        return x.x &lt; y.x;    &#125;);    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) dp[i][j] = 2;    &#125;    for (int i = 1; i &lt;= n; ++ i) &#123;        for (int j = i + 1; j &lt;= n; ++ j) &#123;            for (int k = 1; k &lt; i; ++ k) &#123;                if (x_mul(mv(p[k], p[i]), mv(p[i], p[j])) == 0) dp[i][j] = max(dp[i][j], dp[k][i] + 1);            &#125;            ans = max(ans, dp[i][j]);        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;\n\n洛谷 P1355 神秘大三角直接判断就好了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        char ch;        cin &gt;&gt; ch &gt;&gt; x &gt;&gt; ch &gt;&gt; y &gt;&gt; ch;        return;    &#125;&#125;;constexpr int NR = 5;int tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;int main() &#123;    for (int i = 1; i &lt;= 4; ++ i) p[i].read();    for (int i = 1; i &lt;= 3; ++ i) &#123;        int j = i + 1;        if (j == 4) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[4]));        if (tmp == 0) cnt0 ++;        else if (tmp &gt; 0) cnt1 ++;        else cnt_1 ++;    &#125;    if (cnt1 == 3 || cnt_1 == 3) cout &lt;&lt; 1;    else if (cnt0 == 1 &amp;&amp; (cnt1 == 2 || cnt_1 == 2)) cout &lt;&lt; 3;    else if (cnt0 == 2) cout &lt;&lt; 4;    else cout &lt;&lt; 2;    return 0;&#125;\n\n洛谷 P1183 多边形的面积\n把每个加起来就可以了。\n#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;struct node &#123;    int x, y;    void read() &#123;        cin &gt;&gt; x &gt;&gt; y;        return;    &#125;&#125;;constexpr int NR = 1e2 + 5;int n, tmp, cnt1, cnt_1, cnt0;node p[NR];node mv(node x, node y) &#123;    return &#123;y.x - x.x, y.y - x.y&#125;;&#125;int x_mul(node x, node y) &#123;    return x.x * y.y - x.y * y.x;&#125;long long ans;int main() &#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++ i) p[i].read();    for (int i = 1; i &lt;= n; ++ i) &#123;        int j = i + 1;        if (j == n + 1) j = 1;        tmp = x_mul(mv(p[i], p[j]), mv(p[i], p[0]));        ans += tmp;    &#125;    cout &lt;&lt; ans / 2;    return 0;&#125;","categories":["总结"],"tags":["YL总结","概念"]}]